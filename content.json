{"meta":{"title":"Seal's Blog","subtitle":"","description":"","author":"郭玺","url":"https://sealofyou.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-12T10:35:30.000Z","updated":"2021-12-12T10:44:34.627Z","comments":true,"path":"categories/index.html","permalink":"https://sealofyou.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-12T10:39:11.000Z","updated":"2021-12-12T10:44:23.202Z","comments":true,"path":"link/index.html","permalink":"https://sealofyou.github.io/link/index.html","excerpt":"","text":""},{"title":"标题","date":"2021-12-12T10:33:44.000Z","updated":"2021-12-12T10:44:02.292Z","comments":true,"path":"tags/index.html","permalink":"https://sealofyou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"校赛题解","slug":"校赛题解","date":"2021-12-14T11:33:17.000Z","updated":"2021-12-14T12:29:43.484Z","comments":true,"path":"2021/12/14/校赛题解/","link":"","permalink":"https://sealofyou.github.io/2021/12/14/%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"2021校赛：感受：​ 校赛算是选拔蓝桥杯省赛，但是这次题目给了1道签到题+两道语法题+2道算法题（可以保证基本没人写出来的那种）。所以导致只要语法有基础+手速够快就能得奖并且获得蓝桥杯参赛资格。 ​ 然而，因为最后一题因为数据问题（过于氵），导致只要稍微有点思路就能AC，但其实正解没有人写出来，所以这次的校赛其实真的氵。 题解： 等级：语法题解析：​ 从最后一天剩一个开始向前推，每向前一天+1然后*2，总共n-1天。 ​ 一个for循环就行。 代码：12345678910111213141516171819202122232425262728//c#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int sum=1; for(int i=1;i&lt;n;i++) &#123; sum=(sum+1)*2; &#125; printf(&quot;%d&quot;sum); return 0;&#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n;cin&gt;&gt;n; int sum=1; for(int i=1;i&lt;n;i++) &#123; sum=(sum+1)*2; &#125; cout&lt;&lt;sum;&#125; 等级：语法题解析：​ 将头左斜45°，它就变成了一个金字塔形状的数列，然后这样斜着进行更新（指填数）。 ​ 最后直接两重for控制输出即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//c#include&lt;stdio.h&gt;int a[110][110];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int num=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; a[i-j+1][j]=num++; &#125; &#125; for(int i=1;i&lt;=n+1;i++) &#123; for(int j=1;j&lt;=n-i+1;j++) &#123; printf(&quot;%d &quot;a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[110][110];int main()&#123; int n;cin&gt;&gt;n; int num=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; a[i-j+1][j]=num++; &#125; &#125; //cout&lt;&lt;num&lt;&lt;endl; for(int i=1;i&lt;=n+1;i++) &#123; for(int j=1;j&lt;=n-i+1;j++) &#123; cout&lt;&lt;a[i][j]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; &#125; &#125; 等级：算法题（图的dfs）解析：​ 首先要会图的存储，然后每个点dfs，并每次成立的时候情况++就行了。 ​ （新生不建议写[doge]） 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//c++#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100010;int h[N],e[N*2],ne[N*2],idx;int n,m,d[N],num=0;int st[N];int sum=0;void add(int a,int b)&#123; e[idx]=b;ne[idx]=h[a];h[a]=idx++;&#125;void dfs2(int u)&#123; num++;st[u]=1; if(num==4) &#123; sum++; return; &#125; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(num==3 &amp;&amp; st[j]==2) &#123; sum++; continue; &#125; else if(!st[j]) &#123; dfs2(j); st[j]=0; num--; &#125; &#125; st[u]=0;&#125;void dfs(int u)&#123; num=1;st[u]=2; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; dfs2(j); num--; &#125; st[u]=0;&#125;int main()&#123; memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b);add(b,a); d[a]++,d[b]++; &#125;// if(n&lt;=3 || m&lt;=2)//比赛时写的特判情况之一// &#123;// cout&lt;&lt;0;// return 0;// &#125; for(int i=1;i&lt;=n;i++) &#123; dfs(i); &#125; cout&lt;&lt;sum;&#125; 等级：语法题解析：​ 大水题，我上课讲的都比这难。 ​ 时分秒表示出来然后输出就行，我上课讲的个位前补零的情况也没有。 时：a=t/3600 分：b=t%3600/60 秒：c=t%60 代码：123456789101112131415161718192021222324//c#include&lt;stdio.h&gt;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); int a=t/3600,b=t%3600/60,c=t%60; printf(&quot;%d:%d:%d&quot;,a,b,c); &#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t;cin&gt;&gt;t; int a=t/3600,b=t%3600/60,c=t%60; printf(&quot;%d:%d:%d&quot;,a,b,c); &#125; 等级：语法题（暴力）~算法题（线性DP）解析：​ 因为数据特别氵，所以只要思路还好的的暴力都可以过，但是暴力过了其实不代表个人实力。 然而正解是一个思路比较清奇（分组）的线性dp。 ​ 暴力可以问你们杨琳涵学姐、唐鑫学长、赵普学长（他说直接给你们讲线性dp的解法[doge]）和我。 ​ 线性dp版可以找你们赵普学长。(我懒得讲) ​ 新生不建议写（暴力建议练其他题，dp算法还没学） 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//暴力#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int b[N],a[N],idx;bool st[N];int n,k;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t; if(!b[t])a[idx++]=t; b[t]++; &#125; if(k==0) &#123; cout&lt;&lt;idx; return 0; &#125; sort(a,a+idx-1); int sum=0; for(int i=1;i&lt;=k;i++) &#123; sum+=b[i]; st[i]=1; for(int j=i+k;j&lt;=100010;j+=k) &#123; if(st[j-k]==1 &amp;&amp; b[j-k]&lt;b[j]) &#123; sum+=b[j]-b[j-k]; st[j]=1;st[j-k]=0; &#125;else if(st[j-k]==0) &#123; sum+=b[j]; st[j]=1; &#125; &#125; &#125; cout&lt;&lt;sum;&#125;//dp#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int b[N],a[N],idx;int f[N],st[N];int n,k;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t; if(!b[t])a[idx++]=t; b[t]++; &#125; if(k==0) &#123; cout&lt;&lt;idx; return 0; &#125; sort(a,a+idx-1); int sum=0,j,i; for(i=1;i&lt;=k;i++) &#123; int cnt=1; for(int j=i;j&lt;=100000;j+=k,cnt++) &#123; f[cnt]=f[cnt-1]; if(j&gt;=2)f[cnt]=max(f[cnt-2]+b[j],f[cnt]); &#125; sum+=f[cnt-1]; &#125; cout&lt;&lt;sum;&#125;","categories":[],"tags":[{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"ACgame","slug":"ACgame","date":"2021-12-13T03:32:54.000Z","updated":"2021-12-13T15:01:32.751Z","comments":true,"path":"2021/12/13/ACgame/","link":"","permalink":"https://sealofyou.github.io/2021/12/13/ACgame/","excerpt":"","text":"一个简单的小游戏 网址","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"},{"name":"game","slug":"game","permalink":"https://sealofyou.github.io/tags/game/"}]},{"title":"差分","slug":"差分","date":"2021-09-12T05:08:26.000Z","updated":"2021-12-13T15:02:57.860Z","comments":true,"path":"2021/09/12/差分/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分 差分相当于前缀和的逆运算。 目的：数组中一段数+x时间复杂度降低 具体做法：假设一个数组的前缀和为原数组 一维差分： 预处理： 1234567int a[N],b[N];/*(1)*/for(int i=1;i&lt;=n;i++)b[i]=a[i]-a[i-1];/*(2)*/for(int i=1;i&lt;=n;i++)&#123; b[i]+=a[i]; b[i+1]-=a[i];&#125; 添加数： 1234567int l,r,c;while(m--)&#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; b[l]+=c; b[r+1]-=c;&#125; 二维差分： 差分函数： 1234567void insert(int x1,int y1,int x2,int y2,int c)&#123; a[x1][y1]+=c; a[x2+1][y1]-=c; a[x1][y2+1]-=c; a[x2+1][y2+1]+=c;&#125; 预处理： 12for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)insert(i,j,i,j,c); 添加数： 1insert(x1,y1,x2,y2,c);","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"前缀和","slug":"前缀和","date":"2021-09-12T04:56:09.000Z","updated":"2021-12-13T15:03:09.217Z","comments":true,"path":"2021/09/12/前缀和/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 目的：求原数组中某段数的和（O（1）） 具体做法：做一个预处理，定义一个新数组储存原数组前i个数的和 一维前缀和： 预处理： 12int sum[N],a[N];for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; 查找：（求l~r之间的数） 1num=sum[r]-sum[l-1]; 二维前缀和：(当成方格形) 预处理： 1234int sum[N][M],a[N][M];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j-1]-sum[i-1][j]-sum[i][j-1]+a[i][j]; 查找：（求(l1,r1)~(l2,r2)之间的数） 1num=sum[l2][r2]-sum[l2][r1-1]-sum[l1-1][r2]+sum[l1][r1]; 高维前缀和：（类比）","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"STL","slug":"STL","date":"2021-09-11T09:30:06.000Z","updated":"2021-12-13T15:02:40.536Z","comments":true,"path":"2021/09/11/STL/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/STL/","excerpt":"","text":"STL简记","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"hash","slug":"hash","date":"2021-09-11T07:47:14.000Z","updated":"2021-12-13T15:02:16.549Z","comments":true,"path":"2021/09/11/hash/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/hash/","excerpt":"","text":"哈希表目的：将大范围的多个数映射到一个0-N的集合中 常见哈希表：1.普通哈希表处理冲突方式：​ 1.开放寻址法 123456789101112131415161718const int N=2e5+3,num=0x3f3f3f3f;int h[N];int find(int x)&#123; int k=(x%N+N)%N; while(h[k]!=num&amp;&amp;h[k]!=x) &#123; k++; if(k==N)k=0; &#125;&#125;//添加int k=find(x);h[k]=x;//查找int k=find(x);if(h[k]!=num)//存在 else //不存在 ​ 2.拉链法：一个数组存储所有哈希值 常用操作：1.添加2.查找 3.删除（额外数组进行标记，不常用） 代码 123456789101112131415161718const int N=1e5+3;//减少冲突经常取模100003(大于最大集合范围的最小的质数)int h[N],e[N],ne[N],idx;void insert(int x)//添加&#123; int k=(x%N+N)%N; e[idx]=x; ne[idx]=h[k]; h[k]=idx++;&#125;bool find(int x)//查找&#123; int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]) if(e[i]==x)return true; return false;&#125; 2.字符串哈希字符串前缀哈希法：预处理所有前缀的哈希 ​ 1.如何定义前缀的哈希值：将其转化为p进制数 ​ 注：*1.不能将任何数映射为0 ​ *2.不存在冲突时，p=131或13331、Q取2^64时，不存在冲突 好处：可以依照公式求出前缀的哈希值求出一段的哈希值 公式：$$h[R]-h[L-1]*p^(R-L+1)$$ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+10,P=131;int n,m;char str[N];ull h[N],p[N];ull get(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,str+1); p[0]=1; for(int i=1;i&lt;=n;i++) &#123; p[i]=p[i-1]*P; h[i]=h[i-1]*P+str[i]; &#125; while(m--) &#123; int l1,l2,r1,r2; cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2; if(get(l1,r1)==get(l2,r2))cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"Introduction","slug":"Introduction","date":"2021-09-10T09:54:09.000Z","updated":"2021-12-13T15:02:24.214Z","comments":true,"path":"2021/09/10/Introduction/","link":"","permalink":"https://sealofyou.github.io/2021/09/10/Introduction/","excerpt":"","text":"​ 学着搭了个简单的博客，用来简单记录自己的算法学习和游戏相关。","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"},{"name":"game","slug":"game","permalink":"https://sealofyou.github.io/tags/game/"}]}