{"meta":{"title":"Seal's Blog","subtitle":"","description":"","author":"郭玺","url":"https://sealofyou.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-12T10:35:30.000Z","updated":"2021-12-12T10:44:34.627Z","comments":true,"path":"categories/index.html","permalink":"https://sealofyou.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-12T10:39:11.000Z","updated":"2021-12-12T10:44:23.202Z","comments":true,"path":"link/index.html","permalink":"https://sealofyou.github.io/link/index.html","excerpt":"","text":""},{"title":"标题","date":"2021-12-12T10:33:44.000Z","updated":"2021-12-12T10:44:02.292Z","comments":true,"path":"tags/index.html","permalink":"https://sealofyou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"文章归档","slug":"file","date":"2021-12-12T02:54:26.667Z","updated":"2021-09-08T12:52:36.478Z","comments":true,"path":"2021/12/12/file/","link":"","permalink":"https://sealofyou.github.io/2021/12/12/file/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"差分","slug":"差分","date":"2021-09-12T05:08:26.000Z","updated":"2021-09-12T10:09:00.034Z","comments":true,"path":"2021/09/12/差分/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分 差分相当于前缀和的逆运算。 目的：数组中一段数+x时间复杂度降低 具体做法：假设一个数组的前缀和为原数组 一维差分： 预处理： 1234567int a[N],b[N];/*(1)*/for(int i=1;i&lt;=n;i++)b[i]=a[i]-a[i-1];/*(2)*/for(int i=1;i&lt;=n;i++)&#123; b[i]+=a[i]; b[i+1]-=a[i];&#125; 添加数： 1234567int l,r,c;while(m--)&#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; b[l]+=c; b[r+1]-=c;&#125; 二维差分： 差分函数： 1234567void insert(int x1,int y1,int x2,int y2,int c)&#123; a[x1][y1]+=c; a[x2+1][y1]-=c; a[x1][y2+1]-=c; a[x2+1][y2+1]+=c;&#125; 预处理： 12for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)insert(i,j,i,j,c); 添加数： 1insert(x1,y1,x2,y2,c);","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"前缀和","slug":"前缀和","date":"2021-09-12T04:56:09.000Z","updated":"2021-09-12T10:09:15.007Z","comments":true,"path":"2021/09/12/前缀和/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 目的：求原数组中某段数的和（O（1）） 具体做法：做一个预处理，定义一个新数组储存原数组前i个数的和 一维前缀和： 预处理： 12int sum[N],a[N];for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; 查找：（求l~r之间的数） 1num=sum[r]-sum[l-1]; 二维前缀和：(当成方格形) 预处理： 1234int sum[N][M],a[N][M];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j-1]-sum[i-1][j]-sum[i][j-1]+a[i][j]; 查找：（求(l1,r1)~(l2,r2)之间的数） 1num=sum[l2][r2]-sum[l2][r1-1]-sum[l1-1][r2]+sum[l1][r1]; 高维前缀和：（类比）","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"STL","slug":"STL","date":"2021-09-11T09:30:06.000Z","updated":"2021-09-12T10:08:45.856Z","comments":true,"path":"2021/09/11/STL/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/STL/","excerpt":"","text":"STL简记","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"hash","slug":"hash","date":"2021-09-11T07:47:14.000Z","updated":"2021-09-12T10:08:23.844Z","comments":true,"path":"2021/09/11/hash/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/hash/","excerpt":"","text":"哈希表目的：将大范围的多个数映射到一个0-N的集合中 常见哈希表：1.普通哈希表处理冲突方式：​ 1.开放寻址法 123456789101112131415161718const int N=2e5+3,num=0x3f3f3f3f;int h[N];int find(int x)&#123; int k=(x%N+N)%N; while(h[k]!=num&amp;&amp;h[k]!=x) &#123; k++; if(k==N)k=0; &#125;&#125;//添加int k=find(x);h[k]=x;//查找int k=find(x);if(h[k]!=num)//存在 else //不存在 ​ 2.拉链法：一个数组存储所有哈希值 常用操作：1.添加2.查找 3.删除（额外数组进行标记，不常用） 代码 123456789101112131415161718const int N=1e5+3;//减少冲突经常取模100003(大于最大集合范围的最小的质数)int h[N],e[N],ne[N],idx;void insert(int x)//添加&#123; int k=(x%N+N)%N; e[idx]=x; ne[idx]=h[k]; h[k]=idx++;&#125;bool find(int x)//查找&#123; int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]) if(e[i]==x)return true; return false;&#125; 2.字符串哈希字符串前缀哈希法：预处理所有前缀的哈希 ​ 1.如何定义前缀的哈希值：将其转化为p进制数 ​ 注：*1.不能将任何数映射为0 ​ *2.不存在冲突时，p=131或13331、Q取2^64时，不存在冲突 好处：可以依照公式求出前缀的哈希值求出一段的哈希值 公式：$$h[R]-h[L-1]*p^(R-L+1)$$ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+10,P=131;int n,m;char str[N];ull h[N],p[N];ull get(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,str+1); p[0]=1; for(int i=1;i&lt;=n;i++) &#123; p[i]=p[i-1]*P; h[i]=h[i-1]*P+str[i]; &#125; while(m--) &#123; int l1,l2,r1,r2; cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2; if(get(l1,r1)==get(l2,r2))cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"Introduction","slug":"Introduction","date":"2021-09-10T09:54:09.000Z","updated":"2021-09-11T12:51:06.901Z","comments":true,"path":"2021/09/10/Introduction/","link":"","permalink":"https://sealofyou.github.io/2021/09/10/Introduction/","excerpt":"","text":"​ 学着搭了个简单的博客，用来简单记录自己的算法学习和游戏相关。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]}