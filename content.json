{"meta":{"title":"Seal's Blog","subtitle":"","description":"","author":"郭玺","url":"https://sealofyou.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-12T10:35:30.000Z","updated":"2021-12-12T10:44:34.627Z","comments":true,"path":"categories/index.html","permalink":"https://sealofyou.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-12T10:39:11.000Z","updated":"2021-12-12T10:44:23.202Z","comments":true,"path":"link/index.html","permalink":"https://sealofyou.github.io/link/index.html","excerpt":"","text":""},{"title":"标题","date":"2021-12-12T10:33:44.000Z","updated":"2021-12-12T10:44:02.292Z","comments":true,"path":"tags/index.html","permalink":"https://sealofyou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"3956. 截断数组","slug":"3956-截断数组","date":"2023-02-15T00:30:41.000Z","updated":"2023-02-15T00:42:55.562Z","comments":true,"path":"2023/02/15/3956-截断数组/","link":"","permalink":"https://sealofyou.github.io/2023/02/15/3956-%E6%88%AA%E6%96%AD%E6%95%B0%E7%BB%84/","excerpt":"","text":"3956.截断数组原题链接 思路截两段，三数组各元素和相等。 求截断方法数。 判断特殊情况 输入时求总数sum，sum不是3的倍数直接输出0结束。 sum为0时，公式求解。 记得long long。 前缀和求a[1] ~ a[i]是多少，求等于sum/3和sum/3*2的个数 从头到尾求方案数 事件复杂度：O(n) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int a[N];int main()&#123; int n; cin &gt;&gt; n; int sum = 0; for(int i = 1; i &lt;= n; i ++) &#123; cin &gt;&gt; a[i]; sum +=a[i]; a[i] += a[i - 1]; &#125; if(n &lt; 3) &#123; cout &lt;&lt; 0; return 0; &#125; if(sum % 3 != 0) &#123; cout &lt;&lt; 0; return 0; &#125; if(sum == 0) &#123; /* 3 0 1 (n-2) 4 0 3 (n-2) +(n-3) ... n 0 res (1 + (n-2)) * (n-2) */ int num = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] == sum)num ++; &#125; cout &lt;&lt; (long long)(1 + (num - 2)) * (num - 2) / 2; return 0; &#125; sum /= 3; int num1 = 0, num2 = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] == sum)num1 ++; if(a[i] == sum * 2)num2 ++; &#125; // cout &lt;&lt; num1 &lt;&lt; &quot; &quot; &lt;&lt; num2 &lt;&lt; endl; long long res = 0; for(int i = 1; i &lt;= n; i ++) &#123; if(a[i] == sum) &#123; res += num2; &#125; if(a[i] == sum * 2)&#123; num2 --; &#125; &#125; cout &lt;&lt; res; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://sealofyou.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]},{"title":"hexo上线服务器","slug":"hexo上线服务器","date":"2023-02-14T09:52:40.000Z","updated":"2023-02-14T09:56:18.587Z","comments":true,"path":"2023/02/14/hexo上线服务器/","link":"","permalink":"https://sealofyou.github.io/2023/02/14/hexo%E4%B8%8A%E7%BA%BF%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"hexo部署服务器实现原理nginx应用 步骤上线github或gitee省略 新建镜像有原来镜像（新建）直接 1docker run -p 80:80 -p 443:443 -p 20025:22 -itd --name blog seal:latest 安装nginxsudo apt install nginx 修改/etc/nginx/sites-avaliable的defaultsudo打开default（谨防改完发现改不了诈骗） 12cd ../../etc/nginx/sites-avaliablesudo vim default 修改部分12root /var/www/html 改为 root hexo博客文件夹绝对目录。server_name _;添加IP或服务器域名。 重启nginxnginx -s reload 缺点每次都要 1git pull","categories":[{"name":"博客","slug":"博客","permalink":"https://sealofyou.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"部署服务器","slug":"部署服务器","permalink":"https://sealofyou.github.io/tags/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"95.费解的开关","slug":"95.费解的开关","date":"2022-03-02T11:33:29.000Z","updated":"2023-02-08T14:32:14.201Z","comments":true,"path":"2022/03/02/95.费解的开关/","link":"","permalink":"https://sealofyou.github.io/2022/03/02/95.%E8%B4%B9%E8%A7%A3%E7%9A%84%E5%BC%80%E5%85%B3/","excerpt":"","text":"95.费解的开关AcWing 95. 费解的开关 你玩过“拉灯”游戏吗？ 25盏灯排成一个 5×5的方形。 每一个灯都有一个开关，游戏者可以改变它的状态。 每一步，游戏者可以改变某一个灯的状态。 游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。 我们用数字 1表示一盏开着的灯，用数字 0表示关着的灯。 下面这种状态 123451011101101101111000011011 在改变了最左上角的灯的状态后将变成： 123450111111101101111000011011 再改变它正中间的灯后状态将变成： 123450111111001110011010011011 给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6步以内使所有的灯都变亮。 输入格式第一行输入正整数 n，代表数据中共有 n个待解决的游戏初始状态。 以下若干行数据分为 n组，每组数据有 5 行，每行 5个字符。 每组数据描述了一个游戏的初始状态。 各组数据间用一个空行分隔。 输出格式一共输出 n行数据，每行有一个小于等于 6的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。 对于某一个游戏初始状态，若 6步以内无法使所有灯变亮，则输出 −1。 数据范围0&lt;n≤500 输入样例：1234567891011121314151617183001110101110001110101110011101111011111011111111110111111111111111111111111 输出样例：12332-1 题解： 首先我们要想到更改第i行的某一个灯（不改变同一行其它灯的状态）是改变这个灯上（下）的灯。 由此我们可以定下从上到下的方向来一行一行枚举灯的亮灭情况（灭就点亮）。（递推由来） 由于我们从上向下枚举，而这种枚举只改变第2-5行的灯，无法判断第一行是否有所更改会导致更少的步数，所以需要枚举第一行所有情况（32钟）。 ps：因为3中的原因，为了简化枚举所有情况的代码[doge]，使用了位运算的操作。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;using namespace std;const int N=10;char a[N][N],b[N][N];int dx[5]=&#123;0,-1,0,1,0&#125;,dy[5]=&#123;0,0,-1,0,1&#125;;void turn(int x,int y)&#123; for(int i=0;i&lt;5;i++) &#123; int tx=x+dx[i],ty=y+dy[i]; if(tx&lt;0 &amp;&amp; tx&gt;=5 &amp;&amp; ty&lt;0 &amp;&amp; ty&gt;=5)continue; a[tx][ty]^=1;//0-&gt;1,1-&gt;0的高级操作。 &#125;&#125;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; for(int i=0;i&lt;5;i++)cin&gt;&gt;a[i]; memcpy(b,a,sizeof a); int res=10; for(int op=0;op&lt;32;op++) &#123; int sum=0; for(int i=0;i&lt;5;i++)if(op&gt;&gt;i&amp;1)turn(0,i),sum++;//如果这个数第i位是1，turn(0,i) for(int i=0;i&lt;4;i++) &#123; for(int j=0;j&lt;5;j++) &#123; if(a[i][j]==&#x27;0&#x27;)turn(i+1,j),sum++; if(sum&gt;res)break; &#125; if(sum&gt;res)break; &#125; int fl=1; for(int i=0;i&lt;5;i++) &#123; if(a[4][i]==&#x27;0&#x27;)fl=0; &#125; if(fl==1)res=min(res,sum); memcpy(a,b,sizeof b); &#125; if(res&lt;=6)cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;-1&lt;&lt;endl; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"#767div2","slug":"767div2","date":"2022-01-27T08:37:34.000Z","updated":"2022-01-27T08:39:08.938Z","comments":true,"path":"2022/01/27/767div2/","link":"","permalink":"https://sealofyou.github.io/2022/01/27/767div2/","excerpt":"","text":"#767（div2）感受掉大分，思路没问题代码各种手误，卡手了。 还有如果有思路不要一会换一道，一会换一道，认真思考而不是换题。 A. Download More RAM原题链接 题意：加内存，有n个加内存的软件，每个需要ai，打开后返回ai并增加bi。求最大的内存。 分析：按a从小到大排序，从头开始遍历，到第一个不满足条件的跳出，此时内存为最大值。 代码：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;#define x first#define y secondusing namespace std;const int N=110;typedef pair&lt;int, int&gt; PII;PII a[N];int n,k;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;k; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].x; for(int i=1;i&lt;=n;i++)cin&gt;&gt;a[i].y; sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) &#123; if(a[i].x&lt;=k)k+=a[i].y; else break; &#125; cout&lt;&lt;k&lt;&lt;endl; &#125;&#125; B. GCD Arrays原题链接 题意：给l，r，k。求区间[l,r]内k个操作内其中任意两个数gcd不为1。 分析：因为数据极大，所以不可能求gcd，肯定是找规律。 特判+求奇数个数。 如果k大于等于奇数个数，输出YES，不然输出NO。 特判：l==r的时候，除了1是NO，以外均是YES 代码：1234567891011121314151617181920212223242526#include&lt;bits/stdc++.h&gt;using namespace std;int l,r,k;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;k; if(r==1) &#123; cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; continue; &#125; if(l==r &amp;&amp; l!=1) &#123; cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; continue; &#125; int num=(r-l)/2; if((r-l)%2==1)num++; if(r%2==1 &amp;&amp; l%2==1)num++; if(num&lt;=k)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125; C. Meximum Array原题链接 题意：新定义MEX概念：数组内第一个没有的非负整数 e.g.MEX({1,2,31,2,3}) =0=0 and MEX({0,1,2,4,50,1,2,4,5}) =3=3. 给定一个数组a，取出前k个数求MEX放到最后，然后从剩下的继续，直到a数组为空。求b数组最大（仅按第几位比较，不比长度）的情况下的长度及每次取出k个数的MEX值。 分析：贪心。 因为n&lt;2*10^5^,所以可以维护一个桶寻找MEX最大值num，然后根据每次找到的MEX最大值遍历a数组，直到满足。记录sum，num的值并重复，直到a数组为空。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int a[N];int s[N],st[N];int b[N];int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; int n;cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) &#123; int num; cin&gt;&gt;num; s[num]++; a[i]=num; &#125; int sum=0; for(int k=1;k&lt;=n;k++) &#123; int num=0,op=0,fl=0; while (s[num])num++; for(int i=k;i&lt;=n;i++) &#123; s[a[i]]--; if(!st[a[i]] &amp;&amp; a[i]&lt;=num)op++,st[a[i]]=1; //当时判断写错了，写成st[i]了艹 if(op==num) &#123; b[sum++]=num; for(int j=0;j&lt;=num;j++)st[j]=0; k=i;fl=1; break; &#125; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; for(int i=0;i&lt;sum;i++)cout&lt;&lt;b[i]&lt;&lt;&#x27; &#x27;; cout&lt;&lt;endl; &#125;&#125; D. Peculiar Movie Preferences原题链接 题意：n个长度不超过3的字符串，使其组合成回文串。 跳过场景，而不是随意选。 分析：分情况讨论 字符长度是1：是回文。 字符长度是2：存进map，reverse然后看是否有回文。 字符长度是3：判自己是否是回文，不是的话存进map，reverse然后看是否有回文。没有的话 前两位放到map中并于之前长度为二的分开（map存的值不一样）。 后两位reverse后从之前字符长度为2中找是否有回文。 以上所有只要有一个回文条件满足，那么输出YES，不然输出NO 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100010;string s;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; int n;cin&gt;&gt;n; map&lt;string,int&gt; q,p; int fl=0; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; if(fl==1)continue; if(s.size()==1)//串长为1，回文 &#123; fl=1;continue; &#125; if(s.size()==2)//串长为2，找之前是否有对应回文出现，并放入新串 &#123; q[s]=1; swap(s[0],s[1]); if(q[s]!=0)fl=1;//2-2 &#125;else &#123; //串长为3，前中两位放map里，中后两位找前面是否有对应回文 if(s[0]==s[2])//回文 &#123; fl=1; continue; &#125; //3-3 必须先判3-3，不然用3-2的判法会有问题 q[s]=1; swap(s[0],s[2]); if(q[s]==1)fl=1; else &#123; swap(s[0],s[2]); string l,r; //l 3-2 l+=s[0];l+=s[1]; q[l]=2; //r 2-3 r+=s[1];r+=s[2]; swap(r[0],r[1]); if(q[r]==1)fl=1; &#125; &#125; &#125; if(fl)cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl; &#125;&#125;/*特殊数据2cabaac*/","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"codeforce","slug":"codeforce","permalink":"https://sealofyou.github.io/tags/codeforce/"}]},{"title":"传智杯","slug":"传智杯","date":"2021-12-19T12:07:36.000Z","updated":"2021-12-19T12:55:03.156Z","comments":true,"path":"2021/12/19/传智杯/","link":"","permalink":"https://sealofyou.github.io/2021/12/19/%E4%BC%A0%E6%99%BA%E6%9D%AF/","excerpt":"","text":"传智杯感受：​ 个人参加的b组，3道签到题+1道暴力/算法题+1道算法题。 ​ 前三题卡到我的是看错题了，舍去小数部分看成整数输出，所以拿了double整数输出（四舍五入），导致wa了。 ​ 第四题找二进制规律优化，因为不会就只写了一个暴力的解法过了3/4左右（？可能吧，一个代码TLE1-16都有过）数据。 题解：A.组原成绩 等级：语法题解析：​ 依据题意直接输出整数即可。 代码：1234567891011#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; double t,h,e; cin&gt;&gt;t&gt;&gt;h&gt;&gt;e; double s=0.2*t+h*0.3+e*0.5; int s1=s; printf(&quot;%d&quot;,s1); return 0;&#125; B.报告赋分 等级：语法题解析：​ 给定一个t，接下来t行每行有一个卷面基础分a和页数p。 根据页数p减卷面分（题意）就行了。 代码：123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int t;cin&gt;&gt;t; while(t--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; if(b&lt;16)a=max(a-10,0); else if(b&gt;20)a=max(a-(b-20),0); cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125; C.竞争得分 等级：语法题解析：​ n表示人数，接下来n个数a1-an。 用数组存a1-an，用ma，mi存最大值和最小值。然后每个数进行一遍得分的运算+输出就行了。 代码：12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100010;double a[N];int main()&#123; int n;cin&gt;&gt;n; double ma=0,mi=10000; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;a[i]; ma=max(ma,a[i]); mi=min(mi,a[i]); &#125; for(int i=1;i&lt;=n;i++) &#123; a[i]=100*(a[i]-mi)/(ma-mi); int sb=a[i];//直接整数输出double的话会因为小数部分四舍五入而出错 printf(&quot;%d &quot;,sb); &#125; return 0;&#125; D.小卡与质数2 等级：算法题解析：二进制规律优化​ 我的解法是一种简单的暴力写法。首先筛质数板子把1e6的所有质数筛出来，然后让小于x的非负整数与其按位异或，最后利用二分查找异或后的数是否是质数，是sum++。时间复杂度O（nmlogcnt），铁过不了但是交的代码会在#1-#16之间TLE，且每次基本不相同。 ​ 正解后补。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798//我知道我过不了但是TLE数据一直在变的代码#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 1e6+10;int primes[N],cnt;bool st[N];void init(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!st[i])primes[cnt++]=i; for(int j=0;primes[j]*i&lt;=n;j++) &#123; st[primes[j]*i]=1; if(i%primes[j]==0)break; &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; init(1000010); while(n--) &#123; int x;cin&gt;&gt;x; int sum=0; for(int i=0;i&lt;x;i++) &#123; int t1=x^i; int t=lower_bound(primes,primes+cnt,t1)-primes; if(primes[t]==t1)sum++; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125;//周围巨佬的AC代码#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;const int N=2e6+10;int pr[N],idx,len=0,res=0;bool st[N];void init(int n)&#123; for(int i=2;i&lt;=n;i++) &#123; if(!st[i]) pr[idx++]=i; for(int j=0;pr[j]&lt;=n/i;j++) &#123; st[pr[j]*i]=1; if(i%pr[j]==0) break; &#125; &#125;&#125;int find(int x)&#123; int num=1,len=0; while(x) &#123; num=num*2; if(x&amp;1) &#123; int t=1; for(int i=1;i&lt;=len;i++) t=t*2; //cout&lt;&lt;num&lt;&lt;&#x27; &#x27;&lt;&lt;t&lt;&lt;&#x27; &#x27;; int r=upper_bound(pr,pr+idx,num-1)-pr; int l=lower_bound(pr,pr+idx,t)-pr; //cout&lt;&lt;l&lt;&lt;&#x27; &#x27;&lt;&lt;r&lt;&lt;endl; res+=r-l; &#125; len++; x&gt;&gt;=1; &#125; return num;&#125;int main()&#123; //freopen(&quot;1.txt&quot;,&quot;r&quot;,stdin); init(N-10); int T; cin&gt;&gt;T; //cout&lt;&lt;idx&lt;&lt;&#x27; &#x27;; while(T--) &#123; int x; cin&gt;&gt;x; len=0;res=0; int l=1,r; r=find(x); cout&lt;&lt;res&lt;&lt;endl; &#125;&#125; E.萝卜数据库 等级：语法题-算法题解析：​ 插入时：用二维数组第一维存字段x，第二维存值y，数组值存出现次数。 ​ 查找时：ma[x] [ymi-yma]之和。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879//二维数组#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1010;int a[N][N],sum[N];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; int b,p,x,y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;b; if(b==1) &#123; cin&gt;&gt;p; for(int i=1;i&lt;=p;i++) &#123; cin&gt;&gt;x&gt;&gt;y; a[x][y]++; &#125; &#125; else &#123; int yma,ymi; cin&gt;&gt;x&gt;&gt;ymi&gt;&gt;yma; int sum=0; for(int i=ymi;i&lt;=yma;i++) &#123; sum+=a[x][i]; //cout&lt;&lt;endl&lt;&lt;x&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125;&#125;//哈希写法#include&lt;bits/stdc++.h&gt;using namespace std;const int N=1010;int a[N][N],sum[N];unordered_map&lt;int,int&gt; ma[N];int main()&#123; int n,k; cin&gt;&gt;n&gt;&gt;k; int b,p,x,y; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;b; if(b==1) &#123; cin&gt;&gt;p; for(int i=1;i&lt;=p;i++) &#123; cin&gt;&gt;x&gt;&gt;y; ma[x][y]++; //cout&lt;&lt;&#x27; &#x27;&lt;&lt;x&lt;&lt;&#x27; &#x27;&lt;&lt;y&lt;&lt;ma[x][y]&lt;&lt;endl; &#125; &#125; else &#123; int yma,ymi; cin&gt;&gt;x&gt;&gt;ymi&gt;&gt;yma; int sum=0; for(int i=ymi;i&lt;=yma;i++) &#123; sum+=ma[x][i]; //cout&lt;&lt;endl&lt;&lt;x&lt;&lt;i&lt;&lt;endl; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"传智杯","slug":"传智杯","permalink":"https://sealofyou.github.io/tags/%E4%BC%A0%E6%99%BA%E6%9D%AF/"}]},{"title":"校赛题解","slug":"校赛题解","date":"2021-12-14T11:33:17.000Z","updated":"2021-12-14T12:39:58.880Z","comments":true,"path":"2021/12/14/校赛题解/","link":"","permalink":"https://sealofyou.github.io/2021/12/14/%E6%A0%A1%E8%B5%9B%E9%A2%98%E8%A7%A3/","excerpt":"","text":"2021校赛：感受：​ 校赛算是选拔蓝桥杯省赛，但是这次题目给了1道签到题+两道语法题+2道算法题（可以保证基本没人写出来的那种）。所以导致只要语法有基础+手速够快就能得奖并且获得蓝桥杯参赛资格。 ​ 然而，因为最后一题因为数据问题（过于氵），导致只要稍微有点思路就能AC，但其实正解没有人写出来，所以这次的校赛其实真的氵。 题解： 等级：语法题解析：​ 从最后一天剩一个开始向前推，每向前一天+1然后*2，总共n-1天。 ​ 一个for循环就行。 代码：12345678910111213141516171819202122232425262728//c#include&lt;stdio.h&gt;int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int sum=1; for(int i=1;i&lt;n;i++) &#123; sum=(sum+1)*2; &#125; printf(&quot;%d&quot;sum); return 0;&#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int n;cin&gt;&gt;n; int sum=1; for(int i=1;i&lt;n;i++) &#123; sum=(sum+1)*2; &#125; cout&lt;&lt;sum;&#125; 等级：语法题解析：​ 将头左斜45°，它就变成了一个金字塔形状的数列，然后这样斜着进行更新（指填数）。 ​ 最后直接两重for控制输出即可。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//c#include&lt;stdio.h&gt;int a[110][110];int main()&#123; int n; scanf(&quot;%d&quot;,&amp;n); int num=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; a[i-j+1][j]=num++; &#125; &#125; for(int i=1;i&lt;=n+1;i++) &#123; for(int j=1;j&lt;=n-i+1;j++) &#123; printf(&quot;%d &quot;a[i][j]); &#125; printf(&quot;\\n&quot;); &#125; &#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[110][110];int main()&#123; int n;cin&gt;&gt;n; int num=1; for(int i=1;i&lt;=n;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; a[i-j+1][j]=num++; &#125; &#125; //cout&lt;&lt;num&lt;&lt;endl; for(int i=1;i&lt;=n+1;i++) &#123; for(int j=1;j&lt;=n-i+1;j++) &#123; cout&lt;&lt;a[i][j]&lt;&lt;&#x27; &#x27;; &#125; cout&lt;&lt;endl; &#125; &#125; 等级：算法题（图的dfs）解析：​ 首先要会图的存储，然后每个点dfs，并每次成立的时候情况++就行了。 ​ （新生不建议写[doge]） 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//c++#include&lt;bits/stdc++.h&gt;using namespace std;const int N=100010;int h[N],e[N*2],ne[N*2],idx;int n,m,d[N],num=0;int st[N];int sum=0;void add(int a,int b)&#123; e[idx]=b;ne[idx]=h[a];h[a]=idx++;&#125;void dfs2(int u)&#123; num++;st[u]=1; if(num==4) &#123; sum++; return; &#125; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; if(num==3 &amp;&amp; st[j]==2) &#123; sum++; continue; &#125; else if(!st[j]) &#123; dfs2(j); st[j]=0; num--; &#125; &#125; st[u]=0;&#125;void dfs(int u)&#123; num=1;st[u]=2; for(int i=h[u];i!=-1;i=ne[i]) &#123; int j=e[i]; dfs2(j); num--; &#125; st[u]=0;&#125;int main()&#123; memset(h,-1,sizeof h); cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=m;i++) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; add(a,b);add(b,a); d[a]++,d[b]++; &#125;// if(n&lt;=3 || m&lt;=2)//比赛时写的特判情况之一// &#123;// cout&lt;&lt;0;// return 0;// &#125; for(int i=1;i&lt;=n;i++) &#123; dfs(i); &#125; cout&lt;&lt;sum;&#125; 等级：语法题解析：​ 大水题，我上课讲的都比这难。 ​ 时分秒表示出来然后输出就行，我上课讲的个位前补零的情况也没有。 时：a=t/3600 分：b=t%3600/60 秒：c=t%60 代码：123456789101112131415161718192021222324//c#include&lt;stdio.h&gt;int main()&#123; int t; scanf(&quot;%d&quot;,&amp;t); int a=t/3600,b=t%3600/60,c=t%60; printf(&quot;%d:%d:%d&quot;,a,b,c); &#125;//c++#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int t;cin&gt;&gt;t; int a=t/3600,b=t%3600/60,c=t%60; printf(&quot;%d:%d:%d&quot;,a,b,c); &#125; 等级：语法题（暴力）~算法题（线性DP）解析：​ 因为数据特别氵，所以只要思路还好的的暴力都可以过，但是暴力过了其实不代表个人实力。 然而正解是一个思路比较清奇（分组）的线性dp。 ​ 暴力可以问你们杨琳涵学姐、唐鑫学长、赵普学长（他说直接给你们讲线性dp的解法[doge]）和我。 ​ 线性dp版可以找你们赵普学长。(我懒得讲) ​ 新生不建议写（暴力建议练其他题，dp算法还没学） 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//暴力#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int b[N],a[N],idx;bool st[N];int n,k;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t; if(!b[t])a[idx++]=t; b[t]++; &#125; if(k==0) &#123; cout&lt;&lt;idx; return 0; &#125; sort(a,a+idx-1); int sum=0; for(int i=1;i&lt;=k;i++) &#123; sum+=b[i]; st[i]=1; for(int j=i+k;j&lt;=100010;j+=k) &#123; if(st[j-k]==1 &amp;&amp; b[j-k]&lt;b[j]) &#123; sum+=b[j]-b[j-k]; st[j]=1;st[j-k]=0; &#125;else if(st[j-k]==0) &#123; sum+=b[j]; st[j]=1; &#125; &#125; &#125; cout&lt;&lt;sum;&#125;//dp#include&lt;bits/stdc++.h&gt;using namespace std;const int N=200010;int b[N],a[N],idx;int f[N],st[N];int n,k;int main()&#123; cin&gt;&gt;n&gt;&gt;k; int t; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;t; if(!b[t])a[idx++]=t; b[t]++; &#125; if(k==0) &#123; cout&lt;&lt;idx; return 0; &#125; sort(a,a+idx-1); int sum=0,j,i; for(i=1;i&lt;=k;i++) &#123; int cnt=1; for(int j=i;j&lt;=100000;j+=k,cnt++) &#123; f[cnt]=f[cnt-1]; if(j&gt;=2)f[cnt]=max(f[cnt-2]+b[j],f[cnt]); &#125; sum+=f[cnt-1]; &#125; cout&lt;&lt;sum;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"ACgame","slug":"ACgame","date":"2021-12-13T03:32:54.000Z","updated":"2021-12-18T08:19:55.228Z","comments":true,"path":"2021/12/13/ACgame/","link":"","permalink":"https://sealofyou.github.io/2021/12/13/ACgame/","excerpt":"","text":"一个简单的小游戏 网址 https://app279.acapp.acwing.com.cn/","categories":[],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"},{"name":"game","slug":"game","permalink":"https://sealofyou.github.io/tags/game/"}]},{"title":"差分","slug":"差分","date":"2021-09-12T05:08:26.000Z","updated":"2021-12-13T15:02:57.860Z","comments":true,"path":"2021/09/12/差分/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%B7%AE%E5%88%86/","excerpt":"","text":"差分 差分相当于前缀和的逆运算。 目的：数组中一段数+x时间复杂度降低 具体做法：假设一个数组的前缀和为原数组 一维差分： 预处理： 1234567int a[N],b[N];/*(1)*/for(int i=1;i&lt;=n;i++)b[i]=a[i]-a[i-1];/*(2)*/for(int i=1;i&lt;=n;i++)&#123; b[i]+=a[i]; b[i+1]-=a[i];&#125; 添加数： 1234567int l,r,c;while(m--)&#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; b[l]+=c; b[r+1]-=c;&#125; 二维差分： 差分函数： 1234567void insert(int x1,int y1,int x2,int y2,int c)&#123; a[x1][y1]+=c; a[x2+1][y1]-=c; a[x1][y2+1]-=c; a[x2+1][y2+1]+=c;&#125; 预处理： 12for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++)insert(i,j,i,j,c); 添加数： 1insert(x1,y1,x2,y2,c);","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"前缀和","slug":"前缀和","date":"2021-09-12T04:56:09.000Z","updated":"2021-12-13T15:03:09.217Z","comments":true,"path":"2021/09/12/前缀和/","link":"","permalink":"https://sealofyou.github.io/2021/09/12/%E5%89%8D%E7%BC%80%E5%92%8C/","excerpt":"","text":"前缀和 目的：求原数组中某段数的和（O（1）） 具体做法：做一个预处理，定义一个新数组储存原数组前i个数的和 一维前缀和： 预处理： 12int sum[N],a[N];for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+a[i]; 查找：（求l~r之间的数） 1num=sum[r]-sum[l-1]; 二维前缀和：(当成方格形) 预处理： 1234int sum[N][M],a[N][M];for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) sum[i][j]=sum[i-1][j-1]-sum[i-1][j]-sum[i][j-1]+a[i][j]; 查找：（求(l1,r1)~(l2,r2)之间的数） 1num=sum[l2][r2]-sum[l2][r1-1]-sum[l1-1][r2]+sum[l1][r1]; 高维前缀和：（类比）","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"STL","slug":"STL","date":"2021-09-11T09:30:06.000Z","updated":"2021-12-13T15:02:40.536Z","comments":true,"path":"2021/09/11/STL/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/STL/","excerpt":"","text":"STL简记","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"hash","slug":"hash","date":"2021-09-11T07:47:14.000Z","updated":"2021-12-13T15:02:16.549Z","comments":true,"path":"2021/09/11/hash/","link":"","permalink":"https://sealofyou.github.io/2021/09/11/hash/","excerpt":"","text":"哈希表目的：将大范围的多个数映射到一个0-N的集合中 常见哈希表：1.普通哈希表处理冲突方式：​ 1.开放寻址法 123456789101112131415161718const int N=2e5+3,num=0x3f3f3f3f;int h[N];int find(int x)&#123; int k=(x%N+N)%N; while(h[k]!=num&amp;&amp;h[k]!=x) &#123; k++; if(k==N)k=0; &#125;&#125;//添加int k=find(x);h[k]=x;//查找int k=find(x);if(h[k]!=num)//存在 else //不存在 ​ 2.拉链法：一个数组存储所有哈希值 常用操作：1.添加2.查找 3.删除（额外数组进行标记，不常用） 代码 123456789101112131415161718const int N=1e5+3;//减少冲突经常取模100003(大于最大集合范围的最小的质数)int h[N],e[N],ne[N],idx;void insert(int x)//添加&#123; int k=(x%N+N)%N; e[idx]=x; ne[idx]=h[k]; h[k]=idx++;&#125;bool find(int x)//查找&#123; int k=(x%N+N)%N; for(int i=h[k];i!=-1;i=ne[i]) if(e[i]==x)return true; return false;&#125; 2.字符串哈希字符串前缀哈希法：预处理所有前缀的哈希 ​ 1.如何定义前缀的哈希值：将其转化为p进制数 ​ 注：*1.不能将任何数映射为0 ​ *2.不存在冲突时，p=131或13331、Q取2^64时，不存在冲突 好处：可以依照公式求出前缀的哈希值求出一段的哈希值 公式：$$h[R]-h[L-1]*p^(R-L+1)$$ 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;typedef unsigned long long ull;const int N=1e5+10,P=131;int n,m;char str[N];ull h[N],p[N];ull get(int l,int r)&#123; return h[r]-h[l-1]*p[r-l+1];&#125;int main()&#123; scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,str+1); p[0]=1; for(int i=1;i&lt;=n;i++) &#123; p[i]=p[i-1]*P; h[i]=h[i-1]*P+str[i]; &#125; while(m--) &#123; int l1,l2,r1,r2; cin&gt;&gt;l1&gt;&gt;r1&gt;&gt;l2&gt;&gt;r2; if(get(l1,r1)==get(l2,r2))cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"}]},{"title":"Introduction","slug":"Introduction","date":"2021-09-10T09:54:09.000Z","updated":"2021-12-13T15:02:24.214Z","comments":true,"path":"2021/09/10/Introduction/","link":"","permalink":"https://sealofyou.github.io/2021/09/10/Introduction/","excerpt":"","text":"​ 学着搭了个简单的博客，用来简单记录自己的算法学习和游戏相关。","categories":[],"tags":[]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://sealofyou.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"博客","slug":"博客","permalink":"https://sealofyou.github.io/categories/%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"AcWing","slug":"AcWing","permalink":"https://sealofyou.github.io/tags/AcWing/"},{"name":"前缀和","slug":"前缀和","permalink":"https://sealofyou.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"name":"部署服务器","slug":"部署服务器","permalink":"https://sealofyou.github.io/tags/%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"题解","slug":"题解","permalink":"https://sealofyou.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"codeforce","slug":"codeforce","permalink":"https://sealofyou.github.io/tags/codeforce/"},{"name":"传智杯","slug":"传智杯","permalink":"https://sealofyou.github.io/tags/%E4%BC%A0%E6%99%BA%E6%9D%AF/"},{"name":"game","slug":"game","permalink":"https://sealofyou.github.io/tags/game/"}]}